// ==UserScript==
// @name         Topptur GPX Overlay
// @namespace    https://github.com/randonee-overlay
// @version      1.3.0
// @description  Overlay GPX tracks on the topptur.guide Leaflet map
// @match        https://topptur.guide/*
// @run-at       document-idle
// @grant        none
// @updateURL    https://raw.githubusercontent.com/JanTheManHeier/randonee-overlay/main/gpx-overlay.user.js
// @downloadURL  https://raw.githubusercontent.com/JanTheManHeier/randonee-overlay/main/gpx-overlay.user.js
// ==/UserScript==

(function () {
  'use strict';

  // ── Configuration ─────────────────────────────────────────────────
  const TRACK_WEIGHT = 4;
  const TRACK_OPACITY = 0.85;
  // Avoid red, blue, green, black — those are used by the site's own overlays
  const COLORS = ['#ff9900', '#9933cc', '#cc0066', '#e6b800', '#00b3b3', '#8b4513', '#ff6699', '#7b68ee'];

  // Remote URL (GitHub Pages). Set to null to disable.
  const REMOTE_URL = 'https://janthemanheier.github.io/randonee-overlay';
  // Local dev server URL (node serve.js). Set to null to disable.
  const DEV_SERVER = 'http://localhost:3456';

  // ── Embedded tracks (fallback when dev server is not running) ─────
  // Auto-generated by: node scripts/convert-gpx.js
  const EMBEDDED_TRACKS = null; // __TRACKS_PLACEHOLDER__

  console.log('[GPX Overlay] Script loaded, waiting for map...');

  // ── Track state ───────────────────────────────────────────────────
  const tracks = [];  // { layer, name, date, color, visible }
  let colorIndex = 0;
  let mapRef = null;
  let leafletRef = null;

  function nextColor() {
    return COLORS[colorIndex++ % COLORS.length];
  }

  // ── Safe map discovery ────────────────────────────────────────────
  let done = false;
  let patched = false;

  const timer = setInterval(() => {
    if (done || patched) return;

    const L = window.L;
    const containers = document.querySelectorAll('.leaflet-container');
    if (!L || containers.length === 0) return;

    let mainContainer = null;
    let maxArea = 0;
    containers.forEach(c => {
      const rect = c.getBoundingClientRect();
      const area = rect.width * rect.height;
      if (area > maxArea) { maxArea = area; mainContainer = c; }
    });
    if (!mainContainer || maxArea === 0) return;

    // Patch exactly once
    patched = true;
    clearInterval(timer);
    console.log(`[GPX Overlay] Found ${containers.length} map(s), targeting largest`);

    const orig = L.Map.prototype.getCenter;
    L.Map.prototype.getCenter = function () {
      if (done) return orig.apply(this, arguments);
      if (this._container === mainContainer) {
        L.Map.prototype.getCenter = orig;
        done = true;
        const result = orig.apply(this, arguments);
        console.log('[GPX Overlay] Captured main map instance');
        setTimeout(() => onMapReady(L, this), 0);
        return result;
      }
      return orig.apply(this, arguments);
    };
    // Keep nudging until the map responds
    const nudge = setInterval(() => {
      if (done) { clearInterval(nudge); return; }
      window.dispatchEvent(new Event('resize'));
    }, 200);
    setTimeout(() => clearInterval(nudge), 30000);
  }, 300);

  setTimeout(() => {
    if (!done) {
      clearInterval(timer);
      console.warn('[GPX Overlay] Timed out');
    }
  }, 30000);

  // ── Map ready ─────────────────────────────────────────────────────
  function onMapReady(L, map) {
    leafletRef = L;
    mapRef = map;

    addUI(map);
    loadTracksFromServer()
      .catch(() => loadTracksFromRemote())
      .catch(() => loadEmbeddedTracks());
  }

  // Try loading tracks from a base URL using tracks.json manifest
  async function loadTracksFromUrl(baseUrl, label) {
    const res = await fetch(`${baseUrl}/tracks.json`);
    if (!res.ok) throw new Error(`${label} returned ${res.status}`);
    const files = await res.json();
    if (!files.length) throw new Error(`no tracks at ${label}`);

    console.log(`[GPX Overlay] Loading ${files.length} track(s) from ${label}`);
    for (const file of files) {
      const gpxRes = await fetch(`${baseUrl}/tracks/${file}`);
      if (!gpxRes.ok) continue;
      const gpxText = await gpxRes.text();
      const { coords, name, date } = parseGpx(gpxText);
      if (coords.length > 0) {
        addTrack(coords, name || file.replace(/\.gpx$/i, ''), false, date);
      }
    }
  }

  // Try loading from local dev server first
  async function loadTracksFromServer() {
    if (!DEV_SERVER) throw new Error('no dev server configured');
    return loadTracksFromUrl(DEV_SERVER, 'dev server');
  }

  // Try loading from remote (GitHub Pages)
  async function loadTracksFromRemote() {
    if (!REMOTE_URL) throw new Error('no remote URL configured');
    return loadTracksFromUrl(REMOTE_URL, 'remote');
  }

  // Fallback: use embedded tracks
  function loadEmbeddedTracks() {
    if (EMBEDDED_TRACKS && EMBEDDED_TRACKS.length > 0) {
      console.log(`[GPX Overlay] Using ${EMBEDDED_TRACKS.length} embedded track(s)`);
      EMBEDDED_TRACKS.forEach(t => {
        if (t.coords && t.coords.length > 0) {
          addTrack(t.coords, t.name, false, t.date || null);
        }
      });
    } else {
      console.log('[GPX Overlay] No tracks loaded (start dev server or rebuild with embedded tracks)');
    }
  }

  // ── Track management ──────────────────────────────────────────────
  function addTrack(coords, name, showOnMap = true, dateStr = null) {
    const L = leafletRef;
    const map = mapRef;
    const color = nextColor();
    const latlngs = coords.map(c => L.latLng(c[0], c[1]));

    const polyline = L.polyline(latlngs, {
      color, weight: TRACK_WEIGHT, opacity: TRACK_OPACITY,
      lineJoin: 'round', lineCap: 'round',
    });
    const startMarker = L.circleMarker(latlngs[0], {
      radius: 7, color: 'white', weight: 2, fillColor: '#00cc44', fillOpacity: 1,
    });
    const endMarker = L.circleMarker(latlngs[latlngs.length - 1], {
      radius: 7, color: 'white', weight: 2, fillColor: '#cc0000', fillOpacity: 1,
    });

    const layer = L.featureGroup([polyline, startMarker, endMarker]);
    if (showOnMap) layer.addTo(map);

    // Parse date
    const date = dateStr ? new Date(dateStr) : null;
    const track = { layer, name, date, color, visible: showOnMap };
    tracks.push(track);

    updateTrackList();
    console.log(`[GPX Overlay] Added "${name}": ${coords.length} points (${color})${showOnMap ? '' : ' [hidden]'}`);
  }

  // ── GPX parser ────────────────────────────────────────────────────
  function parseGpx(gpxText) {
    const doc = new DOMParser().parseFromString(gpxText, 'application/xml');
    const coords = [];
    doc.querySelectorAll('trkpt').forEach(pt => {
      const lat = parseFloat(pt.getAttribute('lat'));
      const lon = parseFloat(pt.getAttribute('lon'));
      if (!isNaN(lat) && !isNaN(lon)) coords.push([lat, lon]);
    });
    const nameEl = doc.querySelector('trk > name');
    const name = nameEl ? nameEl.textContent : null;
    // Extract date from metadata or first trackpoint
    const timeEl = doc.querySelector('metadata > time') || doc.querySelector('trkpt > time');
    const date = timeEl ? timeEl.textContent : null;
    return { coords, name, date };
  }

  // ── UI ────────────────────────────────────────────────────────────
  let trackListEl = null;

  function addUI(map) {
    const style = document.createElement('style');
    style.textContent = `
      .gpx-bar { position:fixed; bottom:80px; right:16px; z-index:10000;
        display:flex; gap:8px; align-items:flex-end; flex-direction:row-reverse; }
      .gpx-btn { background:white; border:2px solid rgba(0,0,0,.2);
        border-radius:8px; padding:8px 14px; cursor:pointer; font:600 13px/1 system-ui,sans-serif;
        color:#333; box-shadow:0 2px 6px rgba(0,0,0,.15); user-select:none; white-space:nowrap; }
      .gpx-btn:hover { background:#f0f0f0; }
      .gpx-dot { display:inline-block; width:10px; height:10px; border-radius:50%;
        margin-right:6px; vertical-align:middle; }
      .gpx-dot.off { opacity:.25; }
      .gpx-tracks { position:fixed; bottom:120px; right:16px; z-index:10000;
        background:white; border:2px solid rgba(0,0,0,.2); border-radius:8px;
        padding:8px 12px; box-shadow:0 2px 6px rgba(0,0,0,.15);
        font:13px/1.6 system-ui,sans-serif; color:#333; max-width:280px; }
      .gpx-tracks:empty { display:none; }
      .gpx-tracks { max-height:60vh; overflow-y:auto; }
      .gpx-year { font-weight:700; font-size:13px; padding:6px 0 2px; cursor:pointer;
        display:flex; align-items:center; gap:4px; user-select:none; border-bottom:1px solid #e0e0e0; margin-bottom:2px; }
      .gpx-year:hover { color:#000; }
      .gpx-year-arrow { font-size:10px; transition:transform .15s; }
      .gpx-year-arrow.collapsed { transform:rotate(-90deg); }
      .gpx-year-group { }
      .gpx-year-group.collapsed { display:none; }
      .gpx-track-item { display:flex; align-items:center; gap:6px; cursor:pointer; padding:2px 0; }
      .gpx-track-item:hover { color:#000; }
      .gpx-track-date { color:#888; font-size:11px; white-space:nowrap; min-width:42px; }
      .gpx-track-name { overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
      .gpx-track-name.off { text-decoration:line-through; opacity:.5; }
      .gpx-track-date.off { opacity:.4; }
    `;
    document.head.appendChild(style);

    // Button bar
    const bar = document.createElement('div');
    bar.className = 'gpx-bar';

    // Upload button
    const upload = document.createElement('button');
    upload.className = 'gpx-btn';
    upload.textContent = 'Upload GPX';
    upload.onclick = (e) => {
      e.stopPropagation();
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = '.gpx';
      input.multiple = true;
      input.onchange = () => {
        Array.from(input.files).forEach(file => {
          const reader = new FileReader();
          reader.onload = () => {
            const { coords, name, date } = parseGpx(reader.result);
            if (coords.length > 0) {
              addTrack(coords, name || file.name.replace(/\.gpx$/i, ''), true, date);
            } else {
              console.warn(`[GPX Overlay] No track points in ${file.name}`);
            }
          };
          reader.readAsText(file);
        });
      };
      input.click();
    };

    // Fit button
    const fit = document.createElement('button');
    fit.className = 'gpx-btn';
    fit.textContent = 'Fit to Tracks';
    fit.onclick = (e) => {
      e.stopPropagation();
      const visible = tracks.filter(t => t.visible);
      if (visible.length === 0) return;
      let bounds = visible[0].layer.getBounds();
      visible.slice(1).forEach(t => bounds.extend(t.layer.getBounds()));
      map.fitBounds(bounds.pad(0.1));
    };

    // Toggle all button
    const toggleAll = document.createElement('button');
    toggleAll.className = 'gpx-btn';
    toggleAll.innerHTML = '<span class="gpx-dot" style="background:#ff3300"></span>Tracks';
    toggleAll.onclick = (e) => {
      e.stopPropagation();
      const anyVisible = tracks.some(t => t.visible);
      tracks.forEach(t => {
        t.visible = !anyVisible;
        t.visible ? t.layer.addTo(map) : map.removeLayer(t.layer);
      });
      toggleAll.querySelector('.gpx-dot').classList.toggle('off', anyVisible);
      updateTrackList();
    };

    bar.appendChild(upload);
    bar.appendChild(fit);
    bar.appendChild(toggleAll);
    document.body.appendChild(bar);

    // Track list panel (above buttons)
    trackListEl = document.createElement('div');
    trackListEl.className = 'gpx-tracks';
    document.body.appendChild(trackListEl);
  }

  const collapsedYears = new Set();
  const MONTHS = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];

  function formatShortDate(d) {
    if (!d || isNaN(d.getTime())) return '';
    return `${d.getDate()} ${MONTHS[d.getMonth()]}`;
  }

  function updateTrackList() {
    if (!trackListEl) return;
    trackListEl.innerHTML = '';

    // Sort tracks by date (newest first), undated at end
    const sorted = [...tracks].sort((a, b) => {
      if (!a.date && !b.date) return 0;
      if (!a.date) return 1;
      if (!b.date) return -1;
      return b.date - a.date;
    });

    // Group by year
    const groups = {};
    sorted.forEach(t => {
      const year = t.date ? t.date.getFullYear() : 'Other';
      if (!groups[year]) groups[year] = [];
      groups[year].push(t);
    });

    // Render year groups (newest year first)
    const years = Object.keys(groups).sort((a, b) => {
      if (a === 'Other') return 1;
      if (b === 'Other') return -1;
      return parseInt(b) - parseInt(a);
    });

    years.forEach(year => {
      const isCollapsed = collapsedYears.has(year);

      const header = document.createElement('div');
      header.className = 'gpx-year';
      header.innerHTML = `<span class="gpx-year-arrow${isCollapsed ? ' collapsed' : ''}">&#9660;</span> ${year}`;
      header.onclick = () => {
        if (collapsedYears.has(year)) collapsedYears.delete(year);
        else collapsedYears.add(year);
        updateTrackList();
      };
      trackListEl.appendChild(header);

      const group = document.createElement('div');
      group.className = `gpx-year-group${isCollapsed ? ' collapsed' : ''}`;

      groups[year].forEach(t => {
        const item = document.createElement('div');
        item.className = 'gpx-track-item';
        const dateStr = formatShortDate(t.date);
        item.innerHTML =
          `<span class="gpx-dot${t.visible ? '' : ' off'}" style="background:${t.color}"></span>` +
          (dateStr ? `<span class="gpx-track-date${t.visible ? '' : ' off'}">${dateStr}</span>` : '') +
          `<span class="gpx-track-name${t.visible ? '' : ' off'}">${t.name}</span>`;
        item.onclick = () => {
          t.visible = !t.visible;
          t.visible ? t.layer.addTo(mapRef) : mapRef.removeLayer(t.layer);
          updateTrackList();
        };
        group.appendChild(item);
      });

      trackListEl.appendChild(group);
    });
  }
})();
