// ==UserScript==
// @name         Topptur GPX Overlay
// @namespace    https://github.com/randonee-overlay
// @version      1.6.1
// @description  Overlay GPX tracks on the topptur.guide Leaflet map
// @match        https://topptur.guide/*
// @run-at       document-idle
// @grant        none
// @updateURL    https://raw.githubusercontent.com/JanTheManHeier/randonee-overlay/main/gpx-overlay.user.js
// @downloadURL  https://raw.githubusercontent.com/JanTheManHeier/randonee-overlay/main/gpx-overlay.user.js
// ==/UserScript==

(function () {
  'use strict';

  // ── Configuration ─────────────────────────────────────────────────
  const TRACK_WEIGHT = 4;
  const TRACK_OPACITY = 0.85;
  // Avoid red, blue, green, black — those are used by the site's own overlays
  const COLORS = ['#ff9900', '#9933cc', '#cc0066', '#e6b800', '#00b3b3', '#8b4513', '#ff6699', '#7b68ee'];

  // Remote URL (GitHub Pages). Set to null to disable.
  const REMOTE_URL = 'https://janthemanheier.github.io/randonee-overlay';
  // Local dev server URL (node serve.js). Set to null to disable.
  const DEV_SERVER = 'http://localhost:3456';

  const ELE_THRESHOLD = 2;   // meters — ignore elevation changes below this (GPS noise)
  const STOP_SPEED = 0.5;    // km/h — below this, consider stopped
  const MIN_POINTS = 10;     // tracks with fewer points are flagged as incomplete
  const MAX_SEGMENT_JUMP = 2; // km — ignore segments longer than this (GPS glitch)
  const MAX_ELE_JUMP = 200;  // meters — ignore elevation jumps larger than this per segment

  // ── Embedded tracks (fallback when dev server is not running) ─────
  // Auto-generated by: node scripts/convert-gpx.js
  const EMBEDDED_TRACKS = null; // __TRACKS_PLACEHOLDER__

  console.log('[GPX Overlay] Script loaded, waiting for map...');

  // ── Track state ───────────────────────────────────────────────────
  const tracks = [];  // { layer, name, date, color, visible, stats }
  let colorIndex = 0;
  let mapRef = null;
  let leafletRef = null;
  let selectedTrack = null;
  let detailPanelEl = null;
  let profileOverlayEl = null;

  function nextColor() {
    return COLORS[colorIndex++ % COLORS.length];
  }

  // ── Safe map discovery ────────────────────────────────────────────
  let done = false;
  let patched = false;

  const timer = setInterval(() => {
    if (done || patched) return;

    const L = window.L;
    const containers = document.querySelectorAll('.leaflet-container');
    if (!L || containers.length === 0) return;

    let mainContainer = null;
    let maxArea = 0;
    containers.forEach(c => {
      const rect = c.getBoundingClientRect();
      const area = rect.width * rect.height;
      if (area > maxArea) { maxArea = area; mainContainer = c; }
    });
    if (!mainContainer || maxArea === 0) return;

    // Patch exactly once
    patched = true;
    clearInterval(timer);
    console.log(`[GPX Overlay] Found ${containers.length} map(s), targeting largest`);

    const orig = L.Map.prototype.getCenter;
    L.Map.prototype.getCenter = function () {
      if (done) return orig.apply(this, arguments);
      if (this._container === mainContainer) {
        L.Map.prototype.getCenter = orig;
        done = true;
        const result = orig.apply(this, arguments);
        console.log('[GPX Overlay] Captured main map instance');
        setTimeout(() => onMapReady(L, this), 0);
        return result;
      }
      return orig.apply(this, arguments);
    };
    // Keep nudging until the map responds
    const nudge = setInterval(() => {
      if (done) { clearInterval(nudge); return; }
      window.dispatchEvent(new Event('resize'));
    }, 200);
    setTimeout(() => clearInterval(nudge), 30000);
  }, 300);

  setTimeout(() => {
    if (!done) {
      clearInterval(timer);
      console.warn('[GPX Overlay] Timed out');
    }
  }, 30000);

  // ── Map ready ─────────────────────────────────────────────────────
  function onMapReady(L, map) {
    leafletRef = L;
    mapRef = map;

    addUI(map);
    loadTracksFromServer()
      .catch(() => loadTracksFromRemote())
      .catch(() => loadEmbeddedTracks());
  }

  // Try loading tracks from a base URL using tracks.json manifest
  async function loadTracksFromUrl(baseUrl, label) {
    const res = await fetch(`${baseUrl}/tracks.json`);
    if (!res.ok) throw new Error(`${label} returned ${res.status}`);
    const files = await res.json();
    if (!files.length) throw new Error(`no tracks at ${label}`);

    console.log(`[GPX Overlay] Loading ${files.length} track(s) from ${label}`);
    for (const file of files) {
      const gpxRes = await fetch(`${baseUrl}/tracks/${file}`);
      if (!gpxRes.ok) continue;
      const gpxText = await gpxRes.text();
      const { coords, points, name, date } = parseGpx(gpxText);
      if (coords.length > 0) {
        addTrack(coords, name || file.replace(/\.gpx$/i, ''), false, date, points);
      }
    }
  }

  // Try loading from local dev server first
  async function loadTracksFromServer() {
    if (!DEV_SERVER) throw new Error('no dev server configured');
    return loadTracksFromUrl(DEV_SERVER, 'dev server');
  }

  // Try loading from remote (GitHub Pages)
  async function loadTracksFromRemote() {
    if (!REMOTE_URL) throw new Error('no remote URL configured');
    return loadTracksFromUrl(REMOTE_URL, 'remote');
  }

  // Fallback: use embedded tracks
  function loadEmbeddedTracks() {
    if (EMBEDDED_TRACKS && EMBEDDED_TRACKS.length > 0) {
      console.log(`[GPX Overlay] Using ${EMBEDDED_TRACKS.length} embedded track(s)`);
      EMBEDDED_TRACKS.forEach(t => {
        if (t.coords && t.coords.length > 0) {
          // Convert compact [lat, lon, ele, epochMs] to { lat, lon, ele, time }
          const points = t.points ? t.points.map(p => ({
            lat: p[0], lon: p[1], ele: p[2], time: p[3]
          })) : null;
          addTrack(t.coords, t.name, false, t.date || null, points);
        }
      });
    } else {
      console.log('[GPX Overlay] No tracks loaded (start dev server or rebuild with embedded tracks)');
    }
  }

  // ── Stats computation ─────────────────────────────────────────────
  function haversineKm(lat1, lon1, lat2, lon2) {
    const R = 6371;
    const dLat = (lat2 - lat1) * Math.PI / 180;
    const dLon = (lon2 - lon1) * Math.PI / 180;
    const a = Math.sin(dLat / 2) ** 2 +
      Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
      Math.sin(dLon / 2) ** 2;
    return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  }

  function computeTrackStats(points) {
    if (!points || points.length < 2) return null;

    const incomplete = points.length < MIN_POINTS;
    let distance = 0;
    let elevGain = 0;
    let elevLoss = 0;
    let maxEle = -Infinity;
    let minEle = Infinity;
    let movingTimeMs = 0;
    let lastSmoothedEle = points[0].ele;

    const startTime = points[0].time;
    const endTime = points[points.length - 1].time;

    for (let i = 0; i < points.length; i++) {
      const p = points[i];
      if (p.ele !== null) {
        if (p.ele > maxEle) maxEle = p.ele;
        if (p.ele < minEle) minEle = p.ele;
      }
      if (i === 0) continue;

      const prev = points[i - 1];
      const segDist = haversineKm(prev.lat, prev.lon, p.lat, p.lon);

      // Skip GPS glitch segments (huge position jumps)
      if (segDist > MAX_SEGMENT_JUMP) continue;
      distance += segDist;

      if (p.ele !== null && lastSmoothedEle !== null) {
        const delta = p.ele - lastSmoothedEle;
        // Skip unrealistic elevation jumps (GPS glitch)
        if (Math.abs(delta) > MAX_ELE_JUMP) {
          lastSmoothedEle = p.ele;
          continue;
        }
        if (Math.abs(delta) >= ELE_THRESHOLD) {
          if (delta > 0) elevGain += delta;
          else elevLoss += Math.abs(delta);
          lastSmoothedEle = p.ele;
        }
      }

      if (prev.time !== null && p.time !== null) {
        const dtHours = (p.time - prev.time) / 3600000;
        if (dtHours > 0 && segDist <= MAX_SEGMENT_JUMP) {
          const speedKmh = segDist / dtHours;
          if (speedKmh >= STOP_SPEED) {
            movingTimeMs += (p.time - prev.time);
          }
        }
      }
    }

    const elapsedMs = (startTime && endTime) ? endTime - startTime : null;
    const movingTimeHours = movingTimeMs / 3600000;

    return {
      distance: Math.round(distance * 100) / 100,
      elevGain: Math.round(elevGain),
      elevLoss: Math.round(elevLoss),
      maxEle: maxEle === -Infinity ? null : Math.round(maxEle),
      minEle: minEle === Infinity ? null : Math.round(minEle),
      elapsedMs,
      movingTimeMs,
      avgSpeed: movingTimeHours > 0 ? Math.round(distance / movingTimeHours * 10) / 10 : null,
      vertPerHour: movingTimeHours > 0 ? Math.round(elevGain / movingTimeHours) : null,
      startTime,
      endTime,
      incomplete,
    };
  }

  // ── Season helpers ────────────────────────────────────────────────
  function getSeason(date) {
    if (!date || isNaN(date.getTime())) return null;
    const month = date.getMonth(); // 0=Jan, 9=Oct
    const year = date.getFullYear();
    const startYear = month >= 9 ? year : year - 1;
    return `${startYear}/${String(startYear + 1).slice(2)}`;
  }

  function computeSeasonStats() {
    const seasons = {};
    tracks.forEach(t => {
      const season = getSeason(t.date);
      if (!season) return;
      if (!seasons[season]) seasons[season] = {
        trips: 0, elevGain: 0, distance: 0, movingTimeMs: 0,
        maxEles: [], elevGains: [],
      };
      const s = seasons[season];
      s.trips++;
      if (t.stats && !t.stats.incomplete) {
        s.elevGain += t.stats.elevGain;
        s.distance += t.stats.distance;
        s.movingTimeMs += t.stats.movingTimeMs;
        if (t.stats.maxEle !== null) s.maxEles.push(t.stats.maxEle);
        if (t.stats.elevGain > 0) s.elevGains.push(t.stats.elevGain);
      }
    });
    // Compute averages
    Object.values(seasons).forEach(s => {
      const hours = s.movingTimeMs / 3600000;
      s.avgVertPerHour = hours > 0 ? Math.round(s.elevGain / hours) : null;
      s.avgKmPerHour = hours > 0 ? Math.round(s.distance / hours * 10) / 10 : null;
      s.avgMaxEle = s.maxEles.length > 0 ? Math.round(s.maxEles.reduce((a, b) => a + b, 0) / s.maxEles.length) : null;
      s.avgVertPerTrip = s.elevGains.length > 0 ? Math.round(s.elevGains.reduce((a, b) => a + b, 0) / s.elevGains.length) : null;
    });
    return seasons;
  }

  // ── Track management ──────────────────────────────────────────────
  function addTrack(coords, name, showOnMap = true, dateStr = null, points = null) {
    const L = leafletRef;
    const map = mapRef;
    const color = nextColor();
    const latlngs = coords.map(c => L.latLng(c[0], c[1]));

    const polyline = L.polyline(latlngs, {
      color, weight: TRACK_WEIGHT, opacity: TRACK_OPACITY,
      lineJoin: 'round', lineCap: 'round',
    });
    const startMarker = L.circleMarker(latlngs[0], {
      radius: 7, color: 'white', weight: 2, fillColor: '#00cc44', fillOpacity: 1,
    });
    const endMarker = L.circleMarker(latlngs[latlngs.length - 1], {
      radius: 7, color: 'white', weight: 2, fillColor: '#cc0000', fillOpacity: 1,
    });

    const layer = L.featureGroup([polyline, startMarker, endMarker]);
    if (showOnMap) layer.addTo(map);

    // Parse date
    const date = dateStr ? new Date(dateStr) : null;
    const stats = computeTrackStats(points);
    const track = { layer, name, date, color, visible: showOnMap, stats };
    tracks.push(track);

    updateTrackList();
    console.log(`[GPX Overlay] Added "${name}": ${coords.length} points (${color})${showOnMap ? '' : ' [hidden]'}${stats ? ` [${stats.distance}km, +${stats.elevGain}m]` : ''}`);
  }

  // ── GPX parser ────────────────────────────────────────────────────
  function parseGpx(gpxText) {
    const doc = new DOMParser().parseFromString(gpxText, 'application/xml');
    const coords = [];
    const points = [];
    doc.querySelectorAll('trkpt').forEach(pt => {
      const lat = parseFloat(pt.getAttribute('lat'));
      const lon = parseFloat(pt.getAttribute('lon'));
      if (isNaN(lat) || isNaN(lon)) return;
      coords.push([lat, lon]);
      const eleEl = pt.querySelector('ele');
      const timeEl = pt.querySelector('time');
      points.push({
        lat, lon,
        ele: eleEl ? parseFloat(eleEl.textContent) : null,
        time: timeEl ? new Date(timeEl.textContent).getTime() : null,
      });
    });
    const nameEl = doc.querySelector('trk > name');
    const name = nameEl ? nameEl.textContent : null;
    // Extract date from metadata or first trackpoint
    const timeEl = doc.querySelector('metadata > time') || doc.querySelector('trkpt > time');
    const date = timeEl ? timeEl.textContent : null;
    return { coords, points, name, date };
  }

  // ── Formatting helpers ────────────────────────────────────────────
  let trackListEl = null;
  let panelMinimized = window.innerWidth < 600; // start minimized on mobile
  const expandedSeasons = new Set(); // seasons the user has expanded (all start collapsed)
  const MONTHS = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];

  function formatShortDate(d) {
    if (!d || isNaN(d.getTime())) return '';
    return `${d.getDate()} ${MONTHS[d.getMonth()]}`;
  }

  function formatFullDate(d) {
    if (!d || isNaN(d.getTime())) return '';
    return `${d.getDate()} ${MONTHS[d.getMonth()]} ${d.getFullYear()}`;
  }

  function formatDuration(ms) {
    if (!ms || ms <= 0) return '\u2014';
    const totalMin = Math.round(ms / 60000);
    const h = Math.floor(totalMin / 60);
    const m = totalMin % 60;
    return h > 0 ? `${h}h ${m}m` : `${m}m`;
  }

  function formatTime(epochMs) {
    if (!epochMs) return '\u2014';
    const d = new Date(epochMs);
    return `${String(d.getHours()).padStart(2, '0')}:${String(d.getMinutes()).padStart(2, '0')}`;
  }

  // ── Track detail panel ────────────────────────────────────────────
  function showTrackDetail(track) {
    if (!detailPanelEl) {
      detailPanelEl = document.createElement('div');
      detailPanelEl.className = 'gpx-detail';
      document.body.appendChild(detailPanelEl);
    }
    selectedTrack = track;
    const s = track.stats;
    if (!s) {
      detailPanelEl.innerHTML = `
        <div class="gpx-detail-header">
          <div>
            <div class="gpx-detail-title">${track.name}</div>
            <div class="gpx-detail-date">${formatFullDate(track.date)}</div>
          </div>
          <button class="gpx-detail-close" title="Close">&times;</button>
        </div>
        <div style="color:#888">No elevation/time data available</div>`;
      detailPanelEl.querySelector('.gpx-detail-close').onclick = hideTrackDetail;
      detailPanelEl.style.display = 'block';
      return;
    }

    const incompleteWarning = s.incomplete
      ? '<div class="gpx-detail-warning">Incomplete recording — stats may be inaccurate</div>'
      : '';

    detailPanelEl.innerHTML = `
      <div class="gpx-detail-header">
        <div>
          <div class="gpx-detail-title">${track.name}</div>
          <div class="gpx-detail-date">${formatFullDate(track.date)}</div>
        </div>
        <button class="gpx-detail-close" title="Close">&times;</button>
      </div>
      ${incompleteWarning}
      <div class="gpx-detail-grid">
        <div><div class="gpx-detail-label">Distance</div><div class="gpx-detail-value">${s.distance} km</div></div>
        <div><div class="gpx-detail-label">Max elevation</div><div class="gpx-detail-value">${s.maxEle ?? '\u2014'} m</div></div>
        <div><div class="gpx-detail-label">Ascent</div><div class="gpx-detail-value">${s.elevGain} m</div></div>
        <div><div class="gpx-detail-label">Descent</div><div class="gpx-detail-value">${s.elevLoss} m</div></div>
        <div><div class="gpx-detail-label">Elapsed time</div><div class="gpx-detail-value">${formatDuration(s.elapsedMs)}</div></div>
        <div><div class="gpx-detail-label">Moving time</div><div class="gpx-detail-value">${formatDuration(s.movingTimeMs)}</div></div>
        <div><div class="gpx-detail-label">Avg speed</div><div class="gpx-detail-value">${s.avgSpeed ?? '\u2014'} km/h</div></div>
        <div><div class="gpx-detail-label">Start</div><div class="gpx-detail-value">${formatTime(s.startTime)}</div></div>
      </div>
      <div class="gpx-detail-highlight">
        <div class="gpx-detail-label">Vert per hour</div>
        <div class="gpx-detail-value">${s.vertPerHour ?? '\u2014'} m/h</div>
      </div>`;
    detailPanelEl.querySelector('.gpx-detail-close').onclick = hideTrackDetail;
    detailPanelEl.style.display = 'block';
  }

  function hideTrackDetail() {
    if (detailPanelEl) detailPanelEl.style.display = 'none';
    selectedTrack = null;
    updateTrackList();
  }

  // ── Profile overlay ───────────────────────────────────────────────
  function toggleProfileOverlay() {
    if (profileOverlayEl) {
      profileOverlayEl.remove();
      profileOverlayEl = null;
      return;
    }

    const seasons = computeSeasonStats();
    const seasonKeys = Object.keys(seasons).sort((a, b) => parseInt(b) - parseInt(a));

    let totalTrips = 0, totalVert = 0, totalDist = 0, totalMovingMs = 0;
    Object.values(seasons).forEach(s => {
      totalTrips += s.trips;
      totalVert += s.elevGain;
      totalDist += s.distance;
      totalMovingMs += s.movingTimeMs;
    });
    const totalHours = totalMovingMs / 3600000;
    const overallVertPerHour = totalHours > 0 ? Math.round(totalVert / totalHours) : null;
    const overallKmPerHour = totalHours > 0 ? Math.round(totalDist / totalHours * 10) / 10 : null;

    profileOverlayEl = document.createElement('div');
    profileOverlayEl.className = 'gpx-profile-overlay';
    profileOverlayEl.onclick = (e) => {
      if (e.target === profileOverlayEl) toggleProfileOverlay();
    };

    const card = document.createElement('div');
    card.className = 'gpx-profile-card';

    let html = `<div class="gpx-profile-title">Randonee Stats</div>`;
    html += `<div class="gpx-profile-hero">${totalVert.toLocaleString()} m
      <div class="gpx-profile-hero-label">Total elevation gain</div></div>`;
    html += `<div class="gpx-profile-stat-row">
      <span class="gpx-profile-stat-label">Total trips</span>
      <span class="gpx-profile-stat-value">${totalTrips}</span></div>`;
    html += `<div class="gpx-profile-stat-row">
      <span class="gpx-profile-stat-label">Total distance</span>
      <span class="gpx-profile-stat-value">${Math.round(totalDist)} km</span></div>`;
    html += `<div class="gpx-profile-stat-row">
      <span class="gpx-profile-stat-label">Avg vert/hour</span>
      <span class="gpx-profile-stat-value">${overallVertPerHour ?? '\u2014'} m/h</span></div>`;
    html += `<div class="gpx-profile-stat-row" style="margin-bottom:16px">
      <span class="gpx-profile-stat-label">Avg speed</span>
      <span class="gpx-profile-stat-value">${overallKmPerHour ?? '\u2014'} km/h</span></div>`;

    seasonKeys.forEach(key => {
      const s = seasons[key];
      html += `<div class="gpx-profile-season">
        <div class="gpx-profile-season-name">Season ${key}</div>
        <div class="gpx-profile-stat-row">
          <span class="gpx-profile-stat-label">Trips</span>
          <span class="gpx-profile-stat-value">${s.trips}</span></div>
        <div class="gpx-profile-stat-row">
          <span class="gpx-profile-stat-label">Elevation gain</span>
          <span class="gpx-profile-stat-value">${s.elevGain.toLocaleString()} m</span></div>
        <div class="gpx-profile-stat-row">
          <span class="gpx-profile-stat-label">Distance</span>
          <span class="gpx-profile-stat-value">${Math.round(s.distance)} km</span></div>
        <div class="gpx-profile-stat-row">
          <span class="gpx-profile-stat-label">Moving time</span>
          <span class="gpx-profile-stat-value">${formatDuration(s.movingTimeMs)}</span></div>
        <div class="gpx-profile-stat-row">
          <span class="gpx-profile-stat-label">Avg trip height</span>
          <span class="gpx-profile-stat-value">${s.avgMaxEle ?? '\u2014'} m</span></div>
        <div class="gpx-profile-stat-row">
          <span class="gpx-profile-stat-label">Avg vert/trip</span>
          <span class="gpx-profile-stat-value">${s.avgVertPerTrip ? s.avgVertPerTrip.toLocaleString() + ' m' : '\u2014'}</span></div>
        <div class="gpx-profile-stat-row">
          <span class="gpx-profile-stat-label">Avg vert/hour</span>
          <span class="gpx-profile-stat-value">${s.avgVertPerHour ?? '\u2014'} m/h</span></div>
        <div class="gpx-profile-stat-row">
          <span class="gpx-profile-stat-label">Avg speed</span>
          <span class="gpx-profile-stat-value">${s.avgKmPerHour ?? '\u2014'} km/h</span></div>
      </div>`;
    });

    // Trip calculator
    html += `<div class="gpx-calc">
      <div class="gpx-calc-title">Trip Calculator</div>
      <div class="gpx-calc-row">
        <label>Elevation</label>
        <input type="number" id="gpx-calc-vert" placeholder="0" min="0"> <span>meters</span>
      </div>
      <div class="gpx-calc-row">
        <label>Distance</label>
        <input type="number" id="gpx-calc-dist" placeholder="0" min="0" step="0.1"> <span>km</span>
      </div>
      <div class="gpx-calc-result">
        <div class="gpx-calc-result-value" id="gpx-calc-time">\u2014</div>
        <div class="gpx-calc-result-label">Estimated moving time</div>
      </div>
      <div class="gpx-calc-note">Based on your avg: ${overallVertPerHour ?? '?'} m/h vert, ${overallKmPerHour ?? '?'} km/h speed</div>
    </div>`;

    card.innerHTML = html;

    // Wire up calculator inputs
    const calcVert = card.querySelector('#gpx-calc-vert');
    const calcDist = card.querySelector('#gpx-calc-dist');
    const calcResult = card.querySelector('#gpx-calc-time');
    function updateCalc() {
      const vert = parseFloat(calcVert.value) || 0;
      const dist = parseFloat(calcDist.value) || 0;
      if (vert === 0 && dist === 0) { calcResult.textContent = '\u2014'; return; }
      // Use the longer estimate (vert time vs distance time) since ascent is the bottleneck
      const vertHours = overallVertPerHour ? vert / overallVertPerHour : 0;
      const distHours = overallKmPerHour ? dist / overallKmPerHour : 0;
      const hours = Math.max(vertHours, distHours);
      if (hours <= 0) { calcResult.textContent = '\u2014'; return; }
      calcResult.textContent = formatDuration(hours * 3600000);
    }
    calcVert.oninput = updateCalc;
    calcDist.oninput = updateCalc;
    // Prevent overlay close when clicking inputs
    card.querySelectorAll('input').forEach(el => el.onclick = (e) => e.stopPropagation());

    profileOverlayEl.appendChild(card);
    document.body.appendChild(profileOverlayEl);

    const escHandler = (e) => {
      if (e.key === 'Escape' && profileOverlayEl) {
        toggleProfileOverlay();
        document.removeEventListener('keydown', escHandler);
      }
    };
    document.addEventListener('keydown', escHandler);
  }

  // ── UI ────────────────────────────────────────────────────────────
  function addUI(map) {
    const style = document.createElement('style');
    style.textContent = `
      .gpx-bar { position:fixed; bottom:80px; right:16px; z-index:10000;
        display:flex; gap:8px; align-items:flex-end; flex-direction:row-reverse; }
      .gpx-btn { background:white; border:2px solid rgba(0,0,0,.2);
        border-radius:8px; padding:8px 14px; cursor:pointer; font:600 13px/1 system-ui,sans-serif;
        color:#333; box-shadow:0 2px 6px rgba(0,0,0,.15); user-select:none; white-space:nowrap; }
      .gpx-btn:hover { background:#f0f0f0; }
      .gpx-dot { display:inline-block; width:10px; height:10px; border-radius:50%;
        margin-right:6px; vertical-align:middle; cursor:pointer; }
      .gpx-dot.off { opacity:.25; }
      .gpx-tracks { position:fixed; bottom:120px; right:16px; z-index:10000;
        background:white; border:2px solid rgba(0,0,0,.2); border-radius:8px;
        box-shadow:0 2px 6px rgba(0,0,0,.15);
        font:13px/1.6 system-ui,sans-serif; color:#333; max-width:280px; }
      .gpx-tracks:empty { display:none; }
      .gpx-panel-header { display:flex; align-items:center; justify-content:space-between;
        padding:6px 12px; cursor:pointer; user-select:none; border-bottom:1px solid #e8e8e8; }
      .gpx-panel-header:hover { background:#f8f8f8; }
      .gpx-panel-title { font-weight:700; font-size:13px; }
      .gpx-panel-toggle { font-size:10px; color:#888; transition:transform .15s; }
      .gpx-panel-toggle.minimized { transform:rotate(180deg); }
      .gpx-panel-body { max-height:50vh; overflow-y:auto; padding:4px 12px 8px; }
      .gpx-tracks.minimized .gpx-panel-body { display:none; }
      .gpx-tracks.minimized .gpx-panel-header { border-bottom:none; }
      .gpx-year { font-weight:700; font-size:13px; padding:6px 0 2px; cursor:pointer;
        display:flex; align-items:center; gap:4px; user-select:none; border-bottom:1px solid #e0e0e0; margin-bottom:2px; }
      .gpx-year:hover { color:#000; }
      .gpx-year-arrow { font-size:10px; transition:transform .15s; }
      .gpx-year-arrow.collapsed { transform:rotate(-90deg); }
      .gpx-season-stats { font-weight:400; font-size:11px; color:#888; margin-left:auto; }
      .gpx-year-group { }
      .gpx-year-group.collapsed { display:none; }
      .gpx-track-item { display:flex; align-items:center; gap:6px; cursor:pointer; padding:2px 0; }
      .gpx-track-item:hover { background:#f8f8ff; }
      .gpx-track-item.selected { background:#eef0ff; }
      .gpx-track-date { color:#888; font-size:11px; white-space:nowrap; min-width:42px; }
      .gpx-track-name { overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
      .gpx-track-name.off { text-decoration:line-through; opacity:.5; }
      .gpx-track-date.off { opacity:.4; }

      .gpx-detail-warning { background:#fff3cd; color:#856404; font-size:11px;
        padding:4px 8px; border-radius:4px; margin-bottom:6px; }
      .gpx-track-name .gpx-incomplete { color:#cc8800; font-size:10px; margin-left:4px; }

      .gpx-detail { position:fixed; bottom:80px; left:16px; z-index:10000;
        background:white; border:2px solid rgba(0,0,0,.2); border-radius:8px;
        padding:12px 16px; box-shadow:0 2px 6px rgba(0,0,0,.15);
        font:13px/1.6 system-ui,sans-serif; color:#333;
        max-width:300px; min-width:220px; display:none; }
      .gpx-detail-header { display:flex; align-items:flex-start; justify-content:space-between;
        margin-bottom:8px; padding-bottom:6px; border-bottom:1px solid #e0e0e0; }
      .gpx-detail-title { font-weight:700; font-size:14px; line-height:1.3; }
      .gpx-detail-date { color:#888; font-size:12px; }
      .gpx-detail-close { background:none; border:none; cursor:pointer;
        font-size:18px; color:#999; padding:0 0 0 8px; line-height:1; }
      .gpx-detail-close:hover { color:#333; }
      .gpx-detail-grid { display:grid; grid-template-columns:1fr 1fr; gap:4px 12px; }
      .gpx-detail-label { color:#888; font-size:11px; }
      .gpx-detail-value { font-weight:600; font-size:13px; }
      .gpx-detail-highlight { grid-column:1/-1; text-align:center;
        padding:6px 0; margin-top:4px; border-top:1px solid #e0e0e0; }
      .gpx-detail-highlight .gpx-detail-value { font-size:16px; color:#ff9900; }

      .gpx-profile-overlay { position:fixed; inset:0; z-index:10001;
        background:rgba(0,0,0,.5); display:flex; align-items:center; justify-content:center; }
      .gpx-profile-card { background:white; border-radius:12px; padding:24px 28px;
        box-shadow:0 8px 32px rgba(0,0,0,.25); max-width:420px; width:90%;
        font:14px/1.6 system-ui,sans-serif; color:#333;
        max-height:80vh; overflow-y:auto; }
      .gpx-profile-title { font-size:18px; font-weight:700; margin-bottom:16px; }
      .gpx-profile-season { margin-bottom:16px; padding-bottom:12px; border-bottom:1px solid #eee; }
      .gpx-profile-season-name { font-weight:700; font-size:15px; margin-bottom:6px; }
      .gpx-profile-stat-row { display:flex; justify-content:space-between; padding:2px 0; }
      .gpx-profile-stat-label { color:#888; }
      .gpx-profile-stat-value { font-weight:600; }
      .gpx-profile-hero { text-align:center; padding:12px 0;
        font-size:28px; font-weight:700; color:#ff9900; }
      .gpx-profile-hero-label { font-size:12px; color:#888; font-weight:400; }

      .gpx-calc { margin-top:16px; padding-top:16px; border-top:2px solid #e0e0e0; }
      .gpx-calc-title { font-weight:700; font-size:15px; margin-bottom:10px; }
      .gpx-calc-row { display:flex; align-items:center; gap:8px; margin-bottom:8px; }
      .gpx-calc-row label { color:#888; font-size:13px; min-width:80px; }
      .gpx-calc-row input { border:1px solid #ccc; border-radius:4px; padding:6px 8px;
        font:13px system-ui,sans-serif; width:80px; }
      .gpx-calc-row input:focus { outline:none; border-color:#ff9900; }
      .gpx-calc-row span { color:#888; font-size:12px; }
      .gpx-calc-result { background:#f8f5ee; border-radius:8px; padding:12px;
        margin-top:8px; text-align:center; }
      .gpx-calc-result-value { font-size:22px; font-weight:700; color:#ff9900; }
      .gpx-calc-result-label { font-size:11px; color:#888; }
      .gpx-calc-note { font-size:11px; color:#aaa; margin-top:6px; text-align:center; }
    `;
    document.head.appendChild(style);

    // Button bar
    const bar = document.createElement('div');
    bar.className = 'gpx-bar';

    // Upload button
    const upload = document.createElement('button');
    upload.className = 'gpx-btn';
    upload.textContent = 'Upload GPX';
    upload.onclick = (e) => {
      e.stopPropagation();
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = '.gpx';
      input.multiple = true;
      input.onchange = () => {
        Array.from(input.files).forEach(file => {
          const reader = new FileReader();
          reader.onload = () => {
            const { coords, points, name, date } = parseGpx(reader.result);
            if (coords.length > 0) {
              addTrack(coords, name || file.name.replace(/\.gpx$/i, ''), true, date, points);
            } else {
              console.warn(`[GPX Overlay] No track points in ${file.name}`);
            }
          };
          reader.readAsText(file);
        });
      };
      input.click();
    };

    // Fit button
    const fit = document.createElement('button');
    fit.className = 'gpx-btn';
    fit.textContent = 'Fit to Tracks';
    fit.onclick = (e) => {
      e.stopPropagation();
      const visible = tracks.filter(t => t.visible);
      if (visible.length === 0) return;
      let bounds = visible[0].layer.getBounds();
      visible.slice(1).forEach(t => bounds.extend(t.layer.getBounds()));
      map.fitBounds(bounds.pad(0.1));
    };

    // Toggle all button
    const toggleAll = document.createElement('button');
    toggleAll.className = 'gpx-btn';
    toggleAll.innerHTML = '<span class="gpx-dot" style="background:#ff3300"></span>Tracks';
    toggleAll.onclick = (e) => {
      e.stopPropagation();
      const anyVisible = tracks.some(t => t.visible);
      tracks.forEach(t => {
        t.visible = !anyVisible;
        t.visible ? t.layer.addTo(map) : map.removeLayer(t.layer);
      });
      toggleAll.querySelector('.gpx-dot').classList.toggle('off', anyVisible);
      updateTrackList();
    };

    // Stats button
    const statsBtn = document.createElement('button');
    statsBtn.className = 'gpx-btn';
    statsBtn.textContent = 'Stats';
    statsBtn.onclick = (e) => {
      e.stopPropagation();
      toggleProfileOverlay();
    };

    bar.appendChild(upload);
    bar.appendChild(fit);
    bar.appendChild(statsBtn);
    bar.appendChild(toggleAll);
    document.body.appendChild(bar);

    // Track list panel (above buttons)
    trackListEl = document.createElement('div');
    trackListEl.className = 'gpx-tracks';
    document.body.appendChild(trackListEl);
  }

  function updateTrackList() {
    if (!trackListEl) return;
    trackListEl.innerHTML = '';
    trackListEl.className = `gpx-tracks${panelMinimized ? ' minimized' : ''}`;

    // Panel header (always visible)
    const visibleCount = tracks.filter(t => t.visible).length;
    const panelHeader = document.createElement('div');
    panelHeader.className = 'gpx-panel-header';
    panelHeader.innerHTML =
      `<span class="gpx-panel-title">Tracks (${visibleCount}/${tracks.length})</span>` +
      `<span class="gpx-panel-toggle${panelMinimized ? ' minimized' : ''}">&#9660;</span>`;
    panelHeader.onclick = () => {
      panelMinimized = !panelMinimized;
      updateTrackList();
    };
    trackListEl.appendChild(panelHeader);

    // Panel body (hidden when minimized)
    const body = document.createElement('div');
    body.className = 'gpx-panel-body';

    // Sort tracks by date (newest first), undated at end
    const sorted = [...tracks].sort((a, b) => {
      if (!a.date && !b.date) return 0;
      if (!a.date) return 1;
      if (!b.date) return -1;
      return b.date - a.date;
    });

    // Group by season
    const groups = {};
    sorted.forEach(t => {
      const season = getSeason(t.date) || 'Other';
      if (!groups[season]) groups[season] = [];
      groups[season].push(t);
    });

    // Sort season keys (newest first)
    const seasonKeys = Object.keys(groups).sort((a, b) => {
      if (a === 'Other') return 1;
      if (b === 'Other') return -1;
      return parseInt(b) - parseInt(a);
    });

    const seasonStats = computeSeasonStats();

    seasonKeys.forEach(season => {
      const isCollapsed = !expandedSeasons.has(season);
      const stats = seasonStats[season];

      const header = document.createElement('div');
      header.className = 'gpx-year';
      const statsLine = stats
        ? `<span class="gpx-season-stats">${stats.trips} trips &middot; ${stats.elevGain.toLocaleString()}m &middot; ${Math.round(stats.distance)} km</span>`
        : '';
      header.innerHTML = `<span class="gpx-year-arrow${isCollapsed ? ' collapsed' : ''}">&#9660;</span> ${season} ${statsLine}`;
      header.onclick = () => {
        if (expandedSeasons.has(season)) expandedSeasons.delete(season);
        else expandedSeasons.add(season);
        updateTrackList();
      };
      body.appendChild(header);

      const group = document.createElement('div');
      group.className = `gpx-year-group${isCollapsed ? ' collapsed' : ''}`;

      groups[season].forEach(t => {
        const item = document.createElement('div');
        item.className = `gpx-track-item${selectedTrack === t ? ' selected' : ''}`;
        const dateStr = formatShortDate(t.date);
        const incompleteTag = (t.stats && t.stats.incomplete) ? '<span class="gpx-incomplete" title="Incomplete recording">!</span>' : '';
        item.innerHTML =
          `<span class="gpx-dot${t.visible ? '' : ' off'}" style="background:${t.color}"></span>` +
          (dateStr ? `<span class="gpx-track-date${t.visible ? '' : ' off'}">${dateStr}</span>` : '') +
          `<span class="gpx-track-name${t.visible ? '' : ' off'}">${t.name}${incompleteTag}</span>`;

        // Click on dot = toggle visibility
        const dot = item.querySelector('.gpx-dot');
        dot.onclick = (e) => {
          e.stopPropagation();
          t.visible = !t.visible;
          t.visible ? t.layer.addTo(mapRef) : mapRef.removeLayer(t.layer);
          updateTrackList();
        };

        // Click on item = select, show info, and ensure track is visible
        item.onclick = () => {
          if (selectedTrack === t) {
            hideTrackDetail();
          } else {
            if (!t.visible) {
              t.visible = true;
              t.layer.addTo(mapRef);
            }
            showTrackDetail(t);
            updateTrackList();
          }
        };

        group.appendChild(item);
      });

      body.appendChild(group);
    });

    trackListEl.appendChild(body);

    // Restore scroll position on body
    if (!panelMinimized) {
      body.scrollTop = trackListEl._savedScroll || 0;
      body.onscroll = () => { trackListEl._savedScroll = body.scrollTop; };
    }
  }
})();
