<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Topptur of the Day</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { font-family: system-ui, -apple-system, sans-serif; color: #333;
      max-width: 640px; margin: 0 auto; padding: 16px; line-height: 1.5;
      background: #f5f5f5; }

    .header { text-align: center; margin-bottom: 20px; }
    .header h1 { font-size: 24px; margin-bottom: 2px; }
    .header .date { color: #888; font-size: 14px; }

    .loading { text-align: center; padding: 40px; color: #888; }
    .loading .spinner { display: inline-block; width: 28px; height: 28px;
      border: 3px solid #ddd; border-top-color: #ff9900;
      border-radius: 50%; animation: spin 0.8s linear infinite; margin-bottom: 8px; }
    @keyframes spin { to { transform: rotate(360deg); } }

    .error { background: #fee; color: #c00; padding: 12px; border-radius: 8px;
      margin-bottom: 16px; font-size: 13px; }

    /* Weather card */
    .weather-card { background: white; border-radius: 12px; padding: 16px;
      margin-bottom: 16px; box-shadow: 0 1px 4px rgba(0,0,0,.08); }
    .weather-title { font-weight: 700; font-size: 15px; margin-bottom: 10px;
      display: flex; align-items: center; gap: 6px; }
    .weather-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
    .weather-day { background: #f8f8f8; border-radius: 8px; padding: 12px; }
    .weather-day-label { font-weight: 600; font-size: 13px; margin-bottom: 6px; }
    .weather-day-icon { font-size: 28px; margin-bottom: 4px; }
    .weather-day-temp { font-size: 20px; font-weight: 700; }
    .weather-day-details { font-size: 12px; color: #666; margin-top: 4px; }
    .weather-day-details span { display: block; }
    .weather-verdict { margin-top: 12px; padding: 10px; border-radius: 8px;
      font-weight: 600; font-size: 14px; text-align: center; }
    .verdict-go { background: #d4edda; color: #155724; }
    .verdict-maybe { background: #fff3cd; color: #856404; }
    .verdict-nogo { background: #f8d7da; color: #721c24; }

    /* Fitness banner */
    .fitness-banner { background: white; border-radius: 12px; padding: 14px 16px;
      margin-bottom: 16px; box-shadow: 0 1px 4px rgba(0,0,0,.08);
      font-size: 13px; color: #555; }
    .fitness-banner strong { color: #333; }

    /* Section */
    .section { margin-bottom: 20px; }
    .section-title { font-size: 16px; font-weight: 700; margin-bottom: 10px;
      display: flex; align-items: center; gap: 6px; }
    .section-subtitle { font-size: 13px; color: #888; font-weight: 400; }

    /* Tour card */
    .tour-card { background: white; border-radius: 12px; padding: 14px 16px;
      margin-bottom: 10px; box-shadow: 0 1px 4px rgba(0,0,0,.08);
      text-decoration: none; color: inherit; display: block;
      transition: box-shadow 0.15s; }
    .tour-card:hover { box-shadow: 0 2px 8px rgba(0,0,0,.15); }
    .tour-card-header { display: flex; align-items: flex-start; justify-content: space-between;
      margin-bottom: 8px; }
    .tour-card-name { font-weight: 700; font-size: 15px; line-height: 1.3; }
    .tour-card-link { color: #ff9900; font-size: 12px; font-weight: 600;
      white-space: nowrap; margin-left: 8px; }
    .ates-badge { display: inline-block; padding: 2px 8px; border-radius: 4px;
      font-size: 11px; font-weight: 600; color: white; margin-bottom: 6px; }
    .ates-1 { background: #00B050; }
    .ates-2 { background: #0070C0; }
    .ates-3 { background: #FF0000; }
    .ates-4 { background: #000000; }
    .tour-card-stats { display: flex; flex-wrap: wrap; gap: 12px; font-size: 12px; color: #666; }
    .tour-card-stats .stat { display: flex; align-items: center; gap: 3px; }
    .tour-card-stats .stat-icon { font-size: 14px; }
    .tour-card-weather { display: flex; align-items: center; gap: 8px;
      margin-top: 8px; padding-top: 8px; border-top: 1px solid #eee;
      font-size: 12px; color: #666; }
    .tour-card-desc { font-size: 12px; color: #888; margin-top: 6px;
      display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical;
      overflow: hidden; }
    .tour-card-history { font-size: 12px; color: #ff9900; font-weight: 600;
      margin-top: 6px; }
    .wind-ok { color: #155724; }
    .wind-warn { color: #856404; }
    .wind-bad { color: #721c24; }

    .empty-msg { color: #888; font-size: 13px; padding: 12px; text-align: center;
      background: white; border-radius: 8px; }

    .footer { text-align: center; color: #aaa; font-size: 12px; margin-top: 24px;
      padding-top: 16px; border-top: 1px solid #e0e0e0; }
    .footer a { color: #ff9900; }

    .credit { font-size: 11px; color: #aaa; margin-top: 8px; }
    .credit a { color: #999; }
  </style>
</head>
<body>
  <div class="header">
    <h1>Topptur of the Day</h1>
    <div class="date" id="today-date"></div>
  </div>

  <div id="content">
    <div class="loading">
      <div class="spinner"></div>
      <div>Loading weather and tours...</div>
    </div>
  </div>

  <div class="footer">
    <a href="index.html">GPX Overlay install</a> &middot;
    <a href="https://github.com/JanTheManHeier/randonee-overlay">GitHub</a>
    <div class="credit">
      Weather: <a href="https://www.met.no/">MET Norway</a> &middot;
      Tours: <a href="https://topptur.guide/">topptur.guide</a>
    </div>
  </div>

  <script>
    // â”€â”€ Configuration â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const TROMSO = { lat: 69.6492, lon: 18.9553 };
    const TRACKS_URL = 'https://janthemanheier.github.io/randonee-overlay';
    const MET_API = 'https://api.met.no/weatherapi/locationforecast/2.0/compact';
    const USER_AGENT = 'randonee-overlay/1.0 github.com/JanTheManHeier/randonee-overlay';
    const TOPPTUR_BASE = 'https://topptur.guide';
    const MATCH_RADIUS_KM = 1.5;
    const MATCH_ELE_TOLERANCE = 150;
    const SEASON_WINDOW_DAYS = 14;
    const ATES_LABELS = ['Not rated', 'Simple', 'Challenging', 'Complex', 'Extreme'];
    const WIND_LIMIT = 5;
    const WIND_WARN = 8;
    const MIN_TOURING_ASCENT = 400; // ignore quick local runs for fitness estimation

    // Weather symbol â†’ emoji mapping
    const SYMBOL_EMOJI = {
      clearsky_day: 'â˜€ï¸', clearsky_night: 'ğŸŒ™', clearsky_polartwilight: 'â˜€ï¸',
      fair_day: 'ğŸŒ¤ï¸', fair_night: 'ğŸŒ¤ï¸', fair_polartwilight: 'ğŸŒ¤ï¸',
      partlycloudy_day: 'â›…', partlycloudy_night: 'â›…', partlycloudy_polartwilight: 'â›…',
      cloudy: 'â˜ï¸',
      lightrainshowers_day: 'ğŸŒ¦ï¸', lightrainshowers_night: 'ğŸŒ§ï¸',
      lightrain: 'ğŸŒ§ï¸', rain: 'ğŸŒ§ï¸', heavyrain: 'ğŸŒ§ï¸',
      rainshowers_day: 'ğŸŒ¦ï¸', rainshowers_night: 'ğŸŒ§ï¸',
      heavyrainshowers_day: 'ğŸŒ§ï¸', heavyrainshowers_night: 'ğŸŒ§ï¸',
      lightsnowshowers_day: 'ğŸŒ¨ï¸', lightsnowshowers_night: 'ğŸŒ¨ï¸',
      lightsnow: 'ğŸŒ¨ï¸', snow: 'â„ï¸', heavysnow: 'â„ï¸',
      snowshowers_day: 'ğŸŒ¨ï¸', snowshowers_night: 'ğŸŒ¨ï¸',
      heavysnowshowers_day: 'â„ï¸', heavysnowshowers_night: 'â„ï¸',
      sleet: 'ğŸŒ¨ï¸', lightsleet: 'ğŸŒ¨ï¸', heavysleet: 'ğŸŒ¨ï¸',
      sleetshowers_day: 'ğŸŒ¨ï¸', sleetshowers_night: 'ğŸŒ¨ï¸',
      fog: 'ğŸŒ«ï¸',
    };

    function symbolEmoji(code) {
      return SYMBOL_EMOJI[code] || 'ğŸŒ¥ï¸';
    }

    // â”€â”€ Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function haversineKm(lat1, lon1, lat2, lon2) {
      const R = 6371;
      const dLat = (lat2 - lat1) * Math.PI / 180;
      const dLon = (lon2 - lon1) * Math.PI / 180;
      const a = Math.sin(dLat / 2) ** 2 +
        Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
        Math.sin(dLon / 2) ** 2;
      return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    }

    function driveTimeLabel(km) {
      if (km < 25) return '< 30 min';
      if (km < 40) return '30â€“60 min';
      if (km < 65) return '60â€“90 min';
      return '> 90 min';
    }

    function formatDate(d) {
      const months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
      const days = ['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'];
      return `${days[d.getDay()]}, ${d.getDate()} ${months[d.getMonth()]} ${d.getFullYear()}`;
    }

    function dayOfYear(d) {
      const start = new Date(d.getFullYear(), 0, 0);
      return Math.floor((d - start) / 86400000);
    }

    // â”€â”€ Load local tours data (pre-extracted by scripts/fetch-tours.js) â”€â”€
    async function fetchTours() {
      const res = await fetch(`${TRACKS_URL}/topptur-tours.json`);
      if (!res.ok) throw new Error(`Failed to load tours: ${res.status}`);
      return res.json();
    }

    // â”€â”€ Load local track summaries (pre-computed by scripts/build-track-summaries.js) â”€â”€
    async function fetchUserTracks() {
      const res = await fetch(`${TRACKS_URL}/track-summaries.json`);
      if (!res.ok) return [];
      const tracks = await res.json();
      // Parse date strings into Date objects
      return tracks.map(t => ({
        ...t,
        date: t.date ? new Date(t.date) : null,
      }));
    }

    // â”€â”€ Match tracks to tours â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function matchTracksToTours(tours, userTracks) {
      tours.forEach(tour => {
        tour.userMatches = [];
        userTracks.forEach(track => {
          const dist = haversineKm(tour.startLat, tour.startLon, track.startLat, track.startLon);
          const eleClose = track.maxEle === null || tour.maxEle === null ||
            Math.abs(track.maxEle - tour.maxEle) < MATCH_ELE_TOLERANCE;
          if (dist < MATCH_RADIUS_KM && eleClose) {
            tour.userMatches.push(track);
          }
        });
        // Sort matches by date (newest first)
        tour.userMatches.sort((a, b) => (b.date || 0) - (a.date || 0));
      });
    }

    // â”€â”€ Fitness estimation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function percentile(arr, p) {
      const sorted = [...arr].sort((a, b) => a - b);
      return sorted[Math.floor(sorted.length * p)] || sorted[sorted.length - 1];
    }

    function estimateFitness(userTracks) {
      const today = new Date();
      const todayDoy = dayOfYear(today);

      // Only consider proper touring days (not quick local runs)
      const touringTracks = userTracks.filter(t => t.ascent >= MIN_TOURING_ASCENT);

      const nearbyTracks = touringTracks.filter(t => {
        if (!t.date) return false;
        const trackDoy = dayOfYear(t.date);
        const diff = Math.abs(trackDoy - todayDoy);
        const wrappedDiff = Math.min(diff, 365 - diff);
        return wrappedDiff <= SEASON_WINDOW_DAYS;
      });

      // Use 75th percentile to target bigger days (user prefers 800-1200m range)
      const source = nearbyTracks.length >= 3 ? nearbyTracks : touringTracks;
      const period = nearbyTracks.length >= 3 ? `Â±${SEASON_WINDOW_DAYS} days` : 'all-time';
      if (source.length === 0) return { avgAscent: 800, avgDistance: 10, count: 0 };

      return {
        avgAscent: Math.round(percentile(source.map(t => t.ascent), 0.75)),
        avgDistance: Math.round(percentile(source.map(t => t.distance), 0.75) * 10) / 10,
        count: source.length,
        period,
      };
    }

    // â”€â”€ Weather â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    async function fetchWeather() {
      const res = await fetch(`${MET_API}?lat=${TROMSO.lat}&lon=${TROMSO.lon}`, {
        headers: { 'User-Agent': USER_AGENT }
      });
      if (!res.ok) throw new Error(`Weather API returned ${res.status}`);
      return res.json();
    }

    function extractDayForecast(weather, dayOffset) {
      const target = new Date();
      target.setDate(target.getDate() + dayOffset);
      const targetDateStr = target.toISOString().slice(0, 10);

      const timeseries = weather.properties.timeseries;
      // Find entries for the target day, prefer daytime hours (8-16)
      const dayEntries = timeseries.filter(t => t.time.startsWith(targetDateStr));
      if (dayEntries.length === 0) return null;

      // Get midday entry (around 12:00) for representative conditions
      const middayEntry = dayEntries.find(t => t.time.includes('T12:00')) ||
        dayEntries.find(t => t.time.includes('T11:00')) ||
        dayEntries.find(t => t.time.includes('T13:00')) ||
        dayEntries[Math.floor(dayEntries.length / 2)];

      const inst = middayEntry.data.instant.details;
      const next6 = middayEntry.data.next_6_hours;
      const next1 = middayEntry.data.next_1_hours;

      // Find max wind across daytime hours (8-16)
      let maxWind = 0, maxGust = 0;
      dayEntries.forEach(e => {
        const hour = parseInt(e.time.slice(11, 13));
        if (hour >= 7 && hour <= 17) {
          const d = e.data.instant.details;
          if (d.wind_speed > maxWind) maxWind = d.wind_speed;
          if (d.wind_speed_of_gust > maxGust) maxGust = d.wind_speed_of_gust;
        }
      });

      // Sum precipitation across daytime
      let totalPrecip = 0;
      dayEntries.forEach(e => {
        const hour = parseInt(e.time.slice(11, 13));
        if (hour >= 7 && hour <= 17 && e.data.next_1_hours) {
          totalPrecip += e.data.next_1_hours.details.precipitation_amount || 0;
        }
      });

      const symbolCode = (next6 && next6.summary) ? next6.summary.symbol_code :
        (next1 && next1.summary) ? next1.summary.symbol_code : 'cloudy';

      return {
        date: target,
        label: dayOffset === 0 ? 'Today' : 'Tomorrow',
        temp: Math.round(inst.air_temperature),
        tempMax: next6 ? Math.round(next6.details.air_temperature_max) : null,
        tempMin: next6 ? Math.round(next6.details.air_temperature_min) : null,
        wind: Math.round(inst.wind_speed * 10) / 10,
        maxWind: Math.round(maxWind * 10) / 10,
        gust: Math.round(maxGust * 10) / 10,
        cloudCover: Math.round(inst.cloud_area_fraction),
        precip: Math.round(totalPrecip * 10) / 10,
        symbolCode,
      };
    }

    function weatherVerdict(forecast) {
      if (!forecast) return { cls: 'verdict-nogo', text: 'No forecast available' };
      if (forecast.maxWind > WIND_WARN || forecast.precip > 2) {
        return { cls: 'verdict-nogo', text: 'Not recommended â€” strong wind or heavy precipitation' };
      }
      if (forecast.maxWind > WIND_LIMIT || forecast.precip > 0.5) {
        return { cls: 'verdict-maybe', text: 'Marginal conditions â€” check details carefully' };
      }
      return { cls: 'verdict-go', text: 'Good conditions for ski touring!' };
    }

    // â”€â”€ Scoring â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function scoreTour(tour, fitness, todayForecast) {
      let score = 100;

      // Fitness match: prefer tours within 80-120% of typical ascent
      if (fitness.avgAscent > 0) {
        const ratio = tour.ascent / fitness.avgAscent;
        if (ratio >= 0.8 && ratio <= 1.2) score += 20;
        else if (ratio >= 0.5 && ratio <= 1.5) score += 10;
        else if (ratio > 2.0) score -= 20;
      }

      // Drive time: closer is better
      if (tour.distFromTromso < 25) score += 15;
      else if (tour.distFromTromso < 40) score += 10;
      else if (tour.distFromTromso < 55) score += 5;

      // Weather: prefer lower ATES in bad conditions
      if (todayForecast && todayForecast.maxWind > WIND_LIMIT) {
        if (tour.ates <= 1) score += 10;
        else if (tour.ates >= 3) score -= 15;
      }

      // Prefer tours with good ascent (not too trivial)
      if (tour.ascent >= 400 && tour.ascent <= 1000) score += 5;

      return score;
    }

    // â”€â”€ Render â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function renderWeatherCard(today, tomorrow) {
      const verdict = weatherVerdict(today);
      return `
        <div class="weather-card">
          <div class="weather-title">Weather in TromsÃ¸</div>
          <div class="weather-grid">
            ${[today, tomorrow].filter(Boolean).map(f => `
              <div class="weather-day">
                <div class="weather-day-label">${f.label}</div>
                <div class="weather-day-icon">${symbolEmoji(f.symbolCode)}</div>
                <div class="weather-day-temp">${f.temp}Â°C</div>
                <div class="weather-day-details">
                  <span class="${f.maxWind <= WIND_LIMIT ? 'wind-ok' : f.maxWind <= WIND_WARN ? 'wind-warn' : 'wind-bad'}">
                    Wind: ${f.maxWind} m/s (gusts ${f.gust} m/s)</span>
                  <span>Precip: ${f.precip} mm</span>
                  <span>Clouds: ${f.cloudCover}%</span>
                </div>
              </div>
            `).join('')}
          </div>
          <div class="weather-verdict ${verdict.cls}">${verdict.text}</div>
        </div>`;
    }

    function renderTourCard(tour, isNew) {
      let historyHtml = '';
      if (!isNew && tour.userMatches.length > 0) {
        const lastDate = tour.userMatches[0].date;
        const lastStr = lastDate ? `${lastDate.getDate()} ${['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'][lastDate.getMonth()]} ${lastDate.getFullYear()}` : 'unknown date';
        historyHtml = `<div class="tour-card-history">Done ${tour.userMatches.length}x â€” last: ${lastStr}</div>`;
      }

      const descHtml = isNew && tour.description
        ? `<div class="tour-card-desc">${tour.description}</div>` : '';

      return `
        <a class="tour-card" href="${TOPPTUR_BASE}/${tour.id}" target="_blank" rel="noopener">
          <div class="tour-card-header">
            <div>
              <div class="tour-card-name">${tour.name}</div>
              <span class="ates-badge ates-${tour.ates}">${ATES_LABELS[tour.ates] || 'Unknown'}</span>
            </div>
            <span class="tour-card-link">Open â†’</span>
          </div>
          <div class="tour-card-stats">
            <span class="stat"><span class="stat-icon">â†‘</span> ${tour.ascent} m</span>
            <span class="stat"><span class="stat-icon">â›°</span> ${tour.maxEle} m</span>
            <span class="stat"><span class="stat-icon">â†”</span> ${tour.distance} km</span>
            <span class="stat"><span class="stat-icon">ğŸš—</span> ${driveTimeLabel(tour.distFromTromso)}</span>
          </div>
          ${descHtml}
          ${historyHtml}
        </a>`;
    }

    // â”€â”€ Main â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    async function main() {
      document.getElementById('today-date').textContent = formatDate(new Date());
      const contentEl = document.getElementById('content');

      try {
        // Fetch everything in parallel
        const [allTours, weather, userTracks] = await Promise.all([
          fetchTours().catch(err => { console.error('Tours fetch failed:', err); return []; }),
          fetchWeather().catch(err => { console.error('Weather fetch failed:', err); return null; }),
          fetchUserTracks().catch(err => { console.error('Tracks fetch failed:', err); return []; }),
        ]);

        // Tours are already pre-filtered and pre-computed by scripts/fetch-tours.js
        const validTours = allTours;

        // Match user tracks to tours
        matchTracksToTours(validTours, userTracks);

        // Fitness estimation
        const fitness = estimateFitness(userTracks);

        // Weather
        const todayForecast = weather ? extractDayForecast(weather, 0) : null;
        const tomorrowForecast = weather ? extractDayForecast(weather, 1) : null;

        // Score tours
        validTours.forEach(t => {
          t._score = scoreTour(t, fitness, todayForecast);
          t._weather = todayForecast;
        });

        // Split into new and revisit
        const newTours = validTours.filter(t => t.userMatches.length === 0)
          .sort((a, b) => b._score - a._score);
        const revisitTours = validTours.filter(t => t.userMatches.length > 0)
          .sort((a, b) => b._score - a._score);

        // Render
        let html = '';

        // Weather card
        if (todayForecast || tomorrowForecast) {
          html += renderWeatherCard(todayForecast, tomorrowForecast);
        }

        // Fitness banner
        if (fitness.count > 0) {
          html += `<div class="fitness-banner">
            Target based on <strong>${fitness.count} day tours</strong> (${fitness.period}):
            <strong>${fitness.avgAscent} m</strong> ascent, <strong>${fitness.avgDistance} km</strong> distance
          </div>`;
        }

        // New tours
        html += `<div class="section">
          <div class="section-title">Try something new
            <span class="section-subtitle">(${newTours.length} tours you haven't done)</span>
          </div>`;
        if (newTours.length > 0) {
          newTours.slice(0, 5).forEach(t => { html += renderTourCard(t, true); });
        } else {
          html += '<div class="empty-msg">You\'ve done them all! Impressive.</div>';
        }
        html += '</div>';

        // Revisit tours
        html += `<div class="section">
          <div class="section-title">A classic to revisit
            <span class="section-subtitle">(${revisitTours.length} tours you know)</span>
          </div>`;
        if (revisitTours.length > 0) {
          revisitTours.slice(0, 5).forEach(t => { html += renderTourCard(t, false); });
        } else {
          html += '<div class="empty-msg">No matches found with your tracks yet.</div>';
        }
        html += '</div>';

        contentEl.innerHTML = html;

      } catch (err) {
        contentEl.innerHTML = `<div class="error">Failed to load: ${err.message}</div>`;
        console.error(err);
      }
    }

    main();
  </script>
</body>
</html>
